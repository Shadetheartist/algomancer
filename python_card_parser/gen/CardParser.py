# Generated from Card.g4 by ANTLR 4.13.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,133,392,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,1,0,5,0,84,8,0,10,0,12,0,87,9,0,1,0,1,0,1,1,3,1,92,
        8,1,1,1,1,1,1,1,3,1,97,8,1,1,1,1,1,1,1,1,1,3,1,103,8,1,1,1,1,1,1,
        1,3,1,108,8,1,1,2,1,2,1,2,1,2,3,2,114,8,2,1,3,1,3,1,3,3,3,119,8,
        3,1,4,1,4,3,4,123,8,4,1,4,1,4,1,4,1,4,3,4,129,8,4,1,5,1,5,1,5,1,
        5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,144,8,5,1,6,1,6,1,6,1,
        6,3,6,150,8,6,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,
        7,1,7,1,7,1,7,3,7,168,8,7,1,8,1,8,1,8,1,8,3,8,174,8,8,1,9,1,9,1,
        10,1,10,1,10,1,11,1,11,1,12,1,12,1,12,1,12,1,12,1,12,1,12,3,12,190,
        8,12,1,12,1,12,1,12,5,12,195,8,12,10,12,12,12,198,9,12,1,13,1,13,
        1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,3,13,211,8,13,1,14,
        1,14,3,14,215,8,14,1,14,1,14,1,14,1,14,1,14,1,14,3,14,223,8,14,1,
        15,1,15,3,15,227,8,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,5,16,236,
        8,16,10,16,12,16,239,9,16,1,17,1,17,1,17,1,18,1,18,1,19,1,19,1,19,
        1,19,1,19,3,19,251,8,19,1,19,1,19,3,19,255,8,19,1,19,1,19,1,19,1,
        19,1,19,3,19,262,8,19,3,19,264,8,19,1,20,1,20,1,21,1,21,1,21,1,21,
        3,21,272,8,21,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,3,22,282,8,
        22,1,22,1,22,1,22,3,22,287,8,22,1,23,1,23,1,23,1,23,3,23,293,8,23,
        1,24,1,24,1,24,1,24,1,24,1,24,1,25,1,25,1,25,1,25,3,25,305,8,25,
        1,25,1,25,1,25,1,25,1,25,1,25,3,25,313,8,25,1,25,3,25,316,8,25,1,
        25,1,25,1,26,1,26,1,26,1,26,3,26,324,8,26,1,26,1,26,3,26,328,8,26,
        1,27,1,27,1,27,3,27,333,8,27,1,27,1,27,3,27,337,8,27,1,28,1,28,1,
        29,1,29,1,29,1,30,1,30,1,30,1,30,1,31,1,31,1,32,1,32,1,32,1,32,1,
        32,1,32,1,32,3,32,357,8,32,1,33,1,33,3,33,361,8,33,1,34,1,34,3,34,
        365,8,34,1,34,1,34,1,35,1,35,3,35,371,8,35,1,36,1,36,1,36,1,36,1,
        37,1,37,1,37,1,38,1,38,1,39,1,39,3,39,384,8,39,1,40,1,40,1,40,1,
        40,3,40,390,8,40,1,40,0,2,24,32,41,0,2,4,6,8,10,12,14,16,18,20,22,
        24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,
        68,70,72,74,76,78,80,0,11,1,0,3,4,1,0,39,43,1,0,45,57,1,0,32,33,
        2,0,67,67,127,127,2,0,32,32,86,87,1,0,90,91,2,0,32,32,99,101,1,0,
        108,109,1,0,119,123,1,0,126,127,428,0,85,1,0,0,0,2,107,1,0,0,0,4,
        113,1,0,0,0,6,118,1,0,0,0,8,128,1,0,0,0,10,143,1,0,0,0,12,149,1,
        0,0,0,14,167,1,0,0,0,16,173,1,0,0,0,18,175,1,0,0,0,20,177,1,0,0,
        0,22,180,1,0,0,0,24,189,1,0,0,0,26,210,1,0,0,0,28,212,1,0,0,0,30,
        226,1,0,0,0,32,228,1,0,0,0,34,240,1,0,0,0,36,243,1,0,0,0,38,263,
        1,0,0,0,40,265,1,0,0,0,42,271,1,0,0,0,44,286,1,0,0,0,46,292,1,0,
        0,0,48,294,1,0,0,0,50,304,1,0,0,0,52,327,1,0,0,0,54,336,1,0,0,0,
        56,338,1,0,0,0,58,340,1,0,0,0,60,343,1,0,0,0,62,347,1,0,0,0,64,356,
        1,0,0,0,66,360,1,0,0,0,68,362,1,0,0,0,70,368,1,0,0,0,72,372,1,0,
        0,0,74,376,1,0,0,0,76,379,1,0,0,0,78,383,1,0,0,0,80,389,1,0,0,0,
        82,84,3,2,1,0,83,82,1,0,0,0,84,87,1,0,0,0,85,83,1,0,0,0,85,86,1,
        0,0,0,86,88,1,0,0,0,87,85,1,0,0,0,88,89,5,0,0,1,89,1,1,0,0,0,90,
        92,3,66,33,0,91,90,1,0,0,0,91,92,1,0,0,0,92,93,1,0,0,0,93,94,3,4,
        2,0,94,96,5,1,0,0,95,97,3,66,33,0,96,95,1,0,0,0,96,97,1,0,0,0,97,
        98,1,0,0,0,98,99,3,24,12,0,99,100,5,2,0,0,100,108,1,0,0,0,101,103,
        3,66,33,0,102,101,1,0,0,0,102,103,1,0,0,0,103,104,1,0,0,0,104,105,
        3,24,12,0,105,106,5,2,0,0,106,108,1,0,0,0,107,91,1,0,0,0,107,102,
        1,0,0,0,108,3,1,0,0,0,109,110,7,0,0,0,110,114,3,6,3,0,111,114,5,
        5,0,0,112,114,5,6,0,0,113,109,1,0,0,0,113,111,1,0,0,0,113,112,1,
        0,0,0,114,5,1,0,0,0,115,119,3,8,4,0,116,119,3,12,6,0,117,119,3,20,
        10,0,118,115,1,0,0,0,118,116,1,0,0,0,118,117,1,0,0,0,119,7,1,0,0,
        0,120,122,5,7,0,0,121,123,5,8,0,0,122,121,1,0,0,0,122,123,1,0,0,
        0,123,124,1,0,0,0,124,129,3,10,5,0,125,129,5,9,0,0,126,129,5,10,
        0,0,127,129,5,11,0,0,128,120,1,0,0,0,128,125,1,0,0,0,128,126,1,0,
        0,0,128,127,1,0,0,0,129,9,1,0,0,0,130,144,5,12,0,0,131,144,5,13,
        0,0,132,144,5,14,0,0,133,144,5,15,0,0,134,144,5,16,0,0,135,144,5,
        17,0,0,136,144,5,18,0,0,137,144,5,19,0,0,138,139,5,20,0,0,139,140,
        3,76,38,0,140,141,5,21,0,0,141,144,1,0,0,0,142,144,5,22,0,0,143,
        130,1,0,0,0,143,131,1,0,0,0,143,132,1,0,0,0,143,133,1,0,0,0,143,
        134,1,0,0,0,143,135,1,0,0,0,143,136,1,0,0,0,143,137,1,0,0,0,143,
        138,1,0,0,0,143,142,1,0,0,0,144,11,1,0,0,0,145,146,5,23,0,0,146,
        150,3,14,7,0,147,148,5,24,0,0,148,150,3,14,7,0,149,145,1,0,0,0,149,
        147,1,0,0,0,150,13,1,0,0,0,151,152,5,25,0,0,152,168,5,26,0,0,153,
        154,5,27,0,0,154,168,5,28,0,0,155,156,5,29,0,0,156,168,5,28,0,0,
        157,158,5,30,0,0,158,168,5,31,0,0,159,160,5,32,0,0,160,168,5,28,
        0,0,161,162,5,33,0,0,162,168,5,31,0,0,163,164,5,33,0,0,164,168,5,
        34,0,0,165,166,5,35,0,0,166,168,5,36,0,0,167,151,1,0,0,0,167,153,
        1,0,0,0,167,155,1,0,0,0,167,157,1,0,0,0,167,159,1,0,0,0,167,161,
        1,0,0,0,167,163,1,0,0,0,167,165,1,0,0,0,168,15,1,0,0,0,169,170,5,
        37,0,0,170,174,3,18,9,0,171,172,5,38,0,0,172,174,3,18,9,0,173,169,
        1,0,0,0,173,171,1,0,0,0,174,17,1,0,0,0,175,176,7,1,0,0,176,19,1,
        0,0,0,177,178,5,44,0,0,178,179,3,22,11,0,179,21,1,0,0,0,180,181,
        7,2,0,0,181,23,1,0,0,0,182,183,6,12,-1,0,183,190,3,48,24,0,184,190,
        3,34,17,0,185,190,3,36,18,0,186,190,3,38,19,0,187,190,3,50,25,0,
        188,190,3,44,22,0,189,182,1,0,0,0,189,184,1,0,0,0,189,185,1,0,0,
        0,189,186,1,0,0,0,189,187,1,0,0,0,189,188,1,0,0,0,190,196,1,0,0,
        0,191,192,10,1,0,0,192,193,5,58,0,0,193,195,3,24,12,2,194,191,1,
        0,0,0,195,198,1,0,0,0,196,194,1,0,0,0,196,197,1,0,0,0,197,25,1,0,
        0,0,198,196,1,0,0,0,199,211,5,59,0,0,200,211,5,60,0,0,201,211,5,
        61,0,0,202,211,5,62,0,0,203,211,5,63,0,0,204,205,5,64,0,0,205,206,
        3,26,13,0,206,207,5,65,0,0,207,208,3,26,13,0,208,209,5,66,0,0,209,
        211,1,0,0,0,210,199,1,0,0,0,210,200,1,0,0,0,210,201,1,0,0,0,210,
        202,1,0,0,0,210,203,1,0,0,0,210,204,1,0,0,0,211,27,1,0,0,0,212,214,
        5,67,0,0,213,215,3,74,37,0,214,213,1,0,0,0,214,215,1,0,0,0,215,222,
        1,0,0,0,216,223,5,68,0,0,217,218,5,69,0,0,218,223,3,72,36,0,219,
        223,5,70,0,0,220,223,5,71,0,0,221,223,5,72,0,0,222,216,1,0,0,0,222,
        217,1,0,0,0,222,219,1,0,0,0,222,220,1,0,0,0,222,221,1,0,0,0,223,
        29,1,0,0,0,224,227,3,76,38,0,225,227,3,28,14,0,226,224,1,0,0,0,226,
        225,1,0,0,0,227,31,1,0,0,0,228,229,6,16,-1,0,229,230,3,26,13,0,230,
        231,3,30,15,0,231,237,1,0,0,0,232,233,10,1,0,0,233,234,5,73,0,0,
        234,236,3,32,16,2,235,232,1,0,0,0,236,239,1,0,0,0,237,235,1,0,0,
        0,237,238,1,0,0,0,238,33,1,0,0,0,239,237,1,0,0,0,240,241,5,74,0,
        0,241,242,3,32,16,0,242,35,1,0,0,0,243,244,5,75,0,0,244,37,1,0,0,
        0,245,246,5,76,0,0,246,247,7,3,0,0,247,248,5,77,0,0,248,250,3,60,
        30,0,249,251,3,54,27,0,250,249,1,0,0,0,250,251,1,0,0,0,251,254,1,
        0,0,0,252,253,5,78,0,0,253,255,3,62,31,0,254,252,1,0,0,0,254,255,
        1,0,0,0,255,256,1,0,0,0,256,257,5,79,0,0,257,264,1,0,0,0,258,259,
        5,80,0,0,259,261,3,60,30,0,260,262,3,54,27,0,261,260,1,0,0,0,261,
        262,1,0,0,0,262,264,1,0,0,0,263,245,1,0,0,0,263,258,1,0,0,0,264,
        39,1,0,0,0,265,266,5,81,0,0,266,41,1,0,0,0,267,268,7,4,0,0,268,272,
        5,82,0,0,269,270,5,82,0,0,270,272,3,80,40,0,271,267,1,0,0,0,271,
        269,1,0,0,0,272,43,1,0,0,0,273,287,3,40,20,0,274,275,5,83,0,0,275,
        276,3,42,21,0,276,277,5,84,0,0,277,278,5,85,0,0,278,279,7,5,0,0,
        279,281,1,0,0,0,280,282,5,88,0,0,281,280,1,0,0,0,281,282,1,0,0,0,
        282,287,1,0,0,0,283,284,5,89,0,0,284,285,7,6,0,0,285,287,3,46,23,
        0,286,273,1,0,0,0,286,274,1,0,0,0,286,283,1,0,0,0,287,45,1,0,0,0,
        288,289,5,92,0,0,289,293,3,72,36,0,290,293,5,93,0,0,291,293,5,94,
        0,0,292,288,1,0,0,0,292,290,1,0,0,0,292,291,1,0,0,0,293,47,1,0,0,
        0,294,295,5,95,0,0,295,296,3,78,39,0,296,297,3,58,29,0,297,298,5,
        96,0,0,298,299,3,52,26,0,299,49,1,0,0,0,300,301,5,76,0,0,301,302,
        7,3,0,0,302,305,5,77,0,0,303,305,5,97,0,0,304,300,1,0,0,0,304,303,
        1,0,0,0,305,312,1,0,0,0,306,307,3,60,30,0,307,308,5,78,0,0,308,309,
        3,62,31,0,309,313,1,0,0,0,310,313,3,60,30,0,311,313,3,62,31,0,312,
        306,1,0,0,0,312,310,1,0,0,0,312,311,1,0,0,0,313,315,1,0,0,0,314,
        316,3,54,27,0,315,314,1,0,0,0,315,316,1,0,0,0,316,317,1,0,0,0,317,
        318,3,56,28,0,318,51,1,0,0,0,319,328,5,98,0,0,320,321,5,76,0,0,321,
        323,7,3,0,0,322,324,3,54,27,0,323,322,1,0,0,0,323,324,1,0,0,0,324,
        328,1,0,0,0,325,326,5,85,0,0,326,328,7,7,0,0,327,319,1,0,0,0,327,
        320,1,0,0,0,327,325,1,0,0,0,328,53,1,0,0,0,329,332,5,102,0,0,330,
        333,5,103,0,0,331,333,3,72,36,0,332,330,1,0,0,0,332,331,1,0,0,0,
        333,337,1,0,0,0,334,337,5,104,0,0,335,337,5,105,0,0,336,329,1,0,
        0,0,336,334,1,0,0,0,336,335,1,0,0,0,337,55,1,0,0,0,338,339,5,79,
        0,0,339,57,1,0,0,0,340,341,3,60,30,0,341,342,5,106,0,0,342,59,1,
        0,0,0,343,344,3,74,37,0,344,345,5,107,0,0,345,346,3,74,37,0,346,
        61,1,0,0,0,347,348,7,8,0,0,348,63,1,0,0,0,349,357,5,110,0,0,350,
        357,5,111,0,0,351,357,5,112,0,0,352,353,5,113,0,0,353,357,3,76,38,
        0,354,355,5,114,0,0,355,357,3,76,38,0,356,349,1,0,0,0,356,350,1,
        0,0,0,356,351,1,0,0,0,356,352,1,0,0,0,356,354,1,0,0,0,357,65,1,0,
        0,0,358,361,3,68,34,0,359,361,3,70,35,0,360,358,1,0,0,0,360,359,
        1,0,0,0,361,67,1,0,0,0,362,364,5,115,0,0,363,365,3,76,38,0,364,363,
        1,0,0,0,364,365,1,0,0,0,365,366,1,0,0,0,366,367,5,66,0,0,367,69,
        1,0,0,0,368,370,5,116,0,0,369,371,5,117,0,0,370,369,1,0,0,0,370,
        371,1,0,0,0,371,71,1,0,0,0,372,373,5,118,0,0,373,374,7,9,0,0,374,
        375,5,66,0,0,375,73,1,0,0,0,376,377,5,128,0,0,377,378,5,127,0,0,
        378,75,1,0,0,0,379,380,7,10,0,0,380,77,1,0,0,0,381,384,5,23,0,0,
        382,384,3,76,38,0,383,381,1,0,0,0,383,382,1,0,0,0,384,79,1,0,0,0,
        385,386,5,124,0,0,386,390,5,125,0,0,387,388,5,92,0,0,388,390,3,72,
        36,0,389,385,1,0,0,0,389,387,1,0,0,0,390,81,1,0,0,0,41,85,91,96,
        102,107,113,118,122,128,143,149,167,173,189,196,210,214,222,226,
        237,250,254,261,263,271,281,286,292,304,312,315,323,327,332,336,
        356,360,364,370,383,389
    ]

class CardParser ( Parser ):

    grammarFileName = "Card.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "','", "'.'", "'whenever'", "'when'", 
                     "'after combat'", "'at the end of the turn'", "'i'", 
                     "'am'", "'a player plays a nonunit spell targeting me'", 
                     "'you play me'", "'my column deals combat damage'", 
                     "'dealt damage'", "'modded or applied as a mod'", "'survive damage'", 
                     "'die'", "'spawn'", "'despawn'", "'attack'", "'block'", 
                     "'attack in a formation of'", "'or more units'", "'become targeted'", 
                     "'a'", "'another'", "'unit token'", "'is created'", 
                     "'nontoken unit'", "'dies'", "'nontoken enemy'", "'nontoken ally'", 
                     "'spawns'", "'unit'", "'ally'", "'spawns during battle'", 
                     "'card'", "'enters a player's hand during battle'", 
                     "'a player'", "'another player'", "'loses life'", "'loses life during battle'", 
                     "'loses is dealt combat damage'", "'plays a spell'", 
                     "'plays their first spell in this battle'", "'you'", 
                     "'play a spell'", "'play a spell during battle'", "'put a counter on an enemy'", 
                     "'create a token'", "'sacrifice a unit'", "'play a nontoken spell'", 
                     "'are dealt combat damage'", "'deal combat damage to an opponent'", 
                     "'put one or more counters on an ally'", "'play a unit'", 
                     "'apply an augment during battle'", "'do'", "'play a token spell'", 
                     "', then'", "'crystal'", "'robot'", "'fireball'", "'wisp'", 
                     "'poison'", "'/['", "'or'", "']'", "'x'", "', where x is my defense'", 
                     "', where x is your'", "', where x is the defense of the sacrificed unit'", 
                     "', where x is the number of allies adjacent to me'", 
                     "', where x is the greatest defense among your units'", 
                     "'and a'", "'create a'", "'draw a card'", "'target'", 
                     "'gains'", "'and'", "'until regroup'", "'i gain'", 
                     "'i deal damage to each player equal to the number of cards in their hand'", 
                     "'damage'", "'i deal'", "'to'", "'each'", "'player'", 
                     "'opponent'", "'for each blocked column'", "'i deal damage to'", 
                     "'any target'", "'target unit'", "'equal to your'", 
                     "'equal to the number of units you control'", "'equal to the number of units that died in this battle'", 
                     "'put'", "'on'", "'your units gain'", "'me'", "'enemy'", 
                     "'of your units'", "'of the chosen units'", "'for each of your'", 
                     "'units'", "'for each other ally'", "'for each card in your hand'", 
                     "'counter'", "'/'", "'flying'", "'piercing'", "'recall'", 
                     "'ambush'", "'fight'", "'glimpse'", "'rockfall'", "'[graft'", 
                     "'[augment]'", "'[once]'", "'['", "'r'", "'b'", "'e'", 
                     "'g'", "'m'", "'equal to my'", "'defense'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "' '" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "NUMBER_WORD", "DIGIT", 
                      "SIGN", "COMMENT", "META", "PSUDO_NEWLINE", "SPACE", 
                      "NEWLINE" ]

    RULE_prog = 0
    RULE_effect = 1
    RULE_trigger = 2
    RULE_event = 3
    RULE_unit_event = 4
    RULE_unit_event_inner = 5
    RULE_board_event = 6
    RULE_board_event_inner = 7
    RULE_player_event = 8
    RULE_player_event_inner = 9
    RULE_you_event = 10
    RULE_you_event_inner = 11
    RULE_action = 12
    RULE_token_type = 13
    RULE_x_stat = 14
    RULE_token_stat = 15
    RULE_token = 16
    RULE_action_create_token = 17
    RULE_action_draw = 18
    RULE_action_buff = 19
    RULE_sub_action__damage_each_player = 20
    RULE_damage_quantity = 21
    RULE_action_deal_damage = 22
    RULE_damage_quantity_equal_to = 23
    RULE_action_put_counter = 24
    RULE_action_stat_change = 25
    RULE_counter_target = 26
    RULE_region_derived_quantity = 27
    RULE_lifetime = 28
    RULE_counter = 29
    RULE_stat = 30
    RULE_evergreen_keyword = 31
    RULE_keyword = 32
    RULE_mod = 33
    RULE_graft = 34
    RULE_augment = 35
    RULE_affinity = 36
    RULE_signed_int = 37
    RULE_amount = 38
    RULE_amount_item = 39
    RULE_unit_derived_quantity = 40

    ruleNames =  [ "prog", "effect", "trigger", "event", "unit_event", "unit_event_inner", 
                   "board_event", "board_event_inner", "player_event", "player_event_inner", 
                   "you_event", "you_event_inner", "action", "token_type", 
                   "x_stat", "token_stat", "token", "action_create_token", 
                   "action_draw", "action_buff", "sub_action__damage_each_player", 
                   "damage_quantity", "action_deal_damage", "damage_quantity_equal_to", 
                   "action_put_counter", "action_stat_change", "counter_target", 
                   "region_derived_quantity", "lifetime", "counter", "stat", 
                   "evergreen_keyword", "keyword", "mod", "graft", "augment", 
                   "affinity", "signed_int", "amount", "amount_item", "unit_derived_quantity" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    T__80=81
    T__81=82
    T__82=83
    T__83=84
    T__84=85
    T__85=86
    T__86=87
    T__87=88
    T__88=89
    T__89=90
    T__90=91
    T__91=92
    T__92=93
    T__93=94
    T__94=95
    T__95=96
    T__96=97
    T__97=98
    T__98=99
    T__99=100
    T__100=101
    T__101=102
    T__102=103
    T__103=104
    T__104=105
    T__105=106
    T__106=107
    T__107=108
    T__108=109
    T__109=110
    T__110=111
    T__111=112
    T__112=113
    T__113=114
    T__114=115
    T__115=116
    T__116=117
    T__117=118
    T__118=119
    T__119=120
    T__120=121
    T__121=122
    T__122=123
    T__123=124
    T__124=125
    NUMBER_WORD=126
    DIGIT=127
    SIGN=128
    COMMENT=129
    META=130
    PSUDO_NEWLINE=131
    SPACE=132
    NEWLINE=133

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(CardParser.EOF, 0)

        def effect(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CardParser.EffectContext)
            else:
                return self.getTypedRuleContext(CardParser.EffectContext,i)


        def getRuleIndex(self):
            return CardParser.RULE_prog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProg" ):
                listener.enterProg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProg" ):
                listener.exitProg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProg" ):
                return visitor.visitProg(self)
            else:
                return visitor.visitChildren(self)




    def prog(self):

        localctx = CardParser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 85
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 120) != 0) or ((((_la - 74)) & ~0x3f) == 0 and ((1 << (_la - 74)) & 6597080285895) != 0):
                self.state = 82
                self.effect()
                self.state = 87
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 88
            self.match(CardParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EffectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def trigger(self):
            return self.getTypedRuleContext(CardParser.TriggerContext,0)


        def action(self):
            return self.getTypedRuleContext(CardParser.ActionContext,0)


        def mod(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CardParser.ModContext)
            else:
                return self.getTypedRuleContext(CardParser.ModContext,i)


        def getRuleIndex(self):
            return CardParser.RULE_effect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEffect" ):
                listener.enterEffect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEffect" ):
                listener.exitEffect(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEffect" ):
                return visitor.visitEffect(self)
            else:
                return visitor.visitChildren(self)




    def effect(self):

        localctx = CardParser.EffectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_effect)
        self._la = 0 # Token type
        try:
            self.state = 107
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 91
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==115 or _la==116:
                    self.state = 90
                    self.mod()


                self.state = 93
                self.trigger()
                self.state = 94
                self.match(CardParser.T__0)
                self.state = 96
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==115 or _la==116:
                    self.state = 95
                    self.mod()


                self.state = 98
                self.action(0)
                self.state = 99
                self.match(CardParser.T__1)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 102
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==115 or _la==116:
                    self.state = 101
                    self.mod()


                self.state = 104
                self.action(0)
                self.state = 105
                self.match(CardParser.T__1)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TriggerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CardParser.RULE_trigger

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class EndOfTurnTriggerContext(TriggerContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a CardParser.TriggerContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndOfTurnTrigger" ):
                listener.enterEndOfTurnTrigger(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndOfTurnTrigger" ):
                listener.exitEndOfTurnTrigger(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndOfTurnTrigger" ):
                return visitor.visitEndOfTurnTrigger(self)
            else:
                return visitor.visitChildren(self)


    class EventTriggerContext(TriggerContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a CardParser.TriggerContext
            super().__init__(parser)
            self.trigger_word = None # Token
            self.copyFrom(ctx)

        def event(self):
            return self.getTypedRuleContext(CardParser.EventContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventTrigger" ):
                listener.enterEventTrigger(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventTrigger" ):
                listener.exitEventTrigger(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEventTrigger" ):
                return visitor.visitEventTrigger(self)
            else:
                return visitor.visitChildren(self)


    class AfterCombatTriggerContext(TriggerContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a CardParser.TriggerContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAfterCombatTrigger" ):
                listener.enterAfterCombatTrigger(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAfterCombatTrigger" ):
                listener.exitAfterCombatTrigger(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAfterCombatTrigger" ):
                return visitor.visitAfterCombatTrigger(self)
            else:
                return visitor.visitChildren(self)



    def trigger(self):

        localctx = CardParser.TriggerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_trigger)
        self._la = 0 # Token type
        try:
            self.state = 113
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 4]:
                localctx = CardParser.EventTriggerContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 109
                localctx.trigger_word = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==3 or _la==4):
                    localctx.trigger_word = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 110
                self.event()
                pass
            elif token in [5]:
                localctx = CardParser.AfterCombatTriggerContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 111
                self.match(CardParser.T__4)
                pass
            elif token in [6]:
                localctx = CardParser.EndOfTurnTriggerContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 112
                self.match(CardParser.T__5)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unit_event(self):
            return self.getTypedRuleContext(CardParser.Unit_eventContext,0)


        def board_event(self):
            return self.getTypedRuleContext(CardParser.Board_eventContext,0)


        def you_event(self):
            return self.getTypedRuleContext(CardParser.You_eventContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_event

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEvent" ):
                listener.enterEvent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEvent" ):
                listener.exitEvent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEvent" ):
                return visitor.visitEvent(self)
            else:
                return visitor.visitChildren(self)




    def event(self):

        localctx = CardParser.EventContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_event)
        try:
            self.state = 118
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7, 9, 10, 11]:
                self.enterOuterAlt(localctx, 1)
                self.state = 115
                self.unit_event()
                pass
            elif token in [23, 24]:
                self.enterOuterAlt(localctx, 2)
                self.state = 116
                self.board_event()
                pass
            elif token in [44]:
                self.enterOuterAlt(localctx, 3)
                self.state = 117
                self.you_event()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unit_eventContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unit_event_inner(self):
            return self.getTypedRuleContext(CardParser.Unit_event_innerContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_unit_event

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit_event" ):
                listener.enterUnit_event(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit_event" ):
                listener.exitUnit_event(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnit_event" ):
                return visitor.visitUnit_event(self)
            else:
                return visitor.visitChildren(self)




    def unit_event(self):

        localctx = CardParser.Unit_eventContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_unit_event)
        self._la = 0 # Token type
        try:
            self.state = 128
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7]:
                self.enterOuterAlt(localctx, 1)
                self.state = 120
                self.match(CardParser.T__6)
                self.state = 122
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==8:
                    self.state = 121
                    self.match(CardParser.T__7)


                self.state = 124
                self.unit_event_inner()
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 2)
                self.state = 125
                self.match(CardParser.T__8)
                pass
            elif token in [10]:
                self.enterOuterAlt(localctx, 3)
                self.state = 126
                self.match(CardParser.T__9)
                pass
            elif token in [11]:
                self.enterOuterAlt(localctx, 4)
                self.state = 127
                self.match(CardParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unit_event_innerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def amount(self):
            return self.getTypedRuleContext(CardParser.AmountContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_unit_event_inner

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit_event_inner" ):
                listener.enterUnit_event_inner(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit_event_inner" ):
                listener.exitUnit_event_inner(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnit_event_inner" ):
                return visitor.visitUnit_event_inner(self)
            else:
                return visitor.visitChildren(self)




    def unit_event_inner(self):

        localctx = CardParser.Unit_event_innerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_unit_event_inner)
        try:
            self.state = 143
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [12]:
                self.enterOuterAlt(localctx, 1)
                self.state = 130
                self.match(CardParser.T__11)
                pass
            elif token in [13]:
                self.enterOuterAlt(localctx, 2)
                self.state = 131
                self.match(CardParser.T__12)
                pass
            elif token in [14]:
                self.enterOuterAlt(localctx, 3)
                self.state = 132
                self.match(CardParser.T__13)
                pass
            elif token in [15]:
                self.enterOuterAlt(localctx, 4)
                self.state = 133
                self.match(CardParser.T__14)
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 5)
                self.state = 134
                self.match(CardParser.T__15)
                pass
            elif token in [17]:
                self.enterOuterAlt(localctx, 6)
                self.state = 135
                self.match(CardParser.T__16)
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 7)
                self.state = 136
                self.match(CardParser.T__17)
                pass
            elif token in [19]:
                self.enterOuterAlt(localctx, 8)
                self.state = 137
                self.match(CardParser.T__18)
                pass
            elif token in [20]:
                self.enterOuterAlt(localctx, 9)
                self.state = 138
                self.match(CardParser.T__19)
                self.state = 139
                self.amount()
                self.state = 140
                self.match(CardParser.T__20)
                pass
            elif token in [22]:
                self.enterOuterAlt(localctx, 10)
                self.state = 142
                self.match(CardParser.T__21)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Board_eventContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.subject = None # Token
            self.inner = None # Board_event_innerContext

        def board_event_inner(self):
            return self.getTypedRuleContext(CardParser.Board_event_innerContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_board_event

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoard_event" ):
                listener.enterBoard_event(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoard_event" ):
                listener.exitBoard_event(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoard_event" ):
                return visitor.visitBoard_event(self)
            else:
                return visitor.visitChildren(self)




    def board_event(self):

        localctx = CardParser.Board_eventContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_board_event)
        try:
            self.state = 149
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [23]:
                self.enterOuterAlt(localctx, 1)
                self.state = 145
                localctx.subject = self.match(CardParser.T__22)
                self.state = 146
                localctx.inner = self.board_event_inner()
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 2)
                self.state = 147
                localctx.subject = self.match(CardParser.T__23)
                self.state = 148
                localctx.inner = self.board_event_inner()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Board_event_innerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # Token
            self.event_ = None # Token


        def getRuleIndex(self):
            return CardParser.RULE_board_event_inner

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoard_event_inner" ):
                listener.enterBoard_event_inner(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoard_event_inner" ):
                listener.exitBoard_event_inner(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoard_event_inner" ):
                return visitor.visitBoard_event_inner(self)
            else:
                return visitor.visitChildren(self)




    def board_event_inner(self):

        localctx = CardParser.Board_event_innerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_board_event_inner)
        try:
            self.state = 167
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 151
                localctx.type_ = self.match(CardParser.T__24)
                self.state = 152
                localctx.event_ = self.match(CardParser.T__25)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 153
                localctx.type_ = self.match(CardParser.T__26)
                self.state = 154
                localctx.event_ = self.match(CardParser.T__27)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 155
                localctx.type_ = self.match(CardParser.T__28)
                self.state = 156
                localctx.event_ = self.match(CardParser.T__27)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 157
                localctx.type_ = self.match(CardParser.T__29)
                self.state = 158
                localctx.event_ = self.match(CardParser.T__30)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 159
                localctx.type_ = self.match(CardParser.T__31)
                self.state = 160
                localctx.event_ = self.match(CardParser.T__27)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 161
                localctx.type_ = self.match(CardParser.T__32)
                self.state = 162
                localctx.event_ = self.match(CardParser.T__30)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 163
                localctx.type_ = self.match(CardParser.T__32)
                self.state = 164
                localctx.event_ = self.match(CardParser.T__33)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 165
                localctx.type_ = self.match(CardParser.T__34)
                self.state = 166
                localctx.event_ = self.match(CardParser.T__35)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Player_eventContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.subject = None # Token
            self.inner = None # Player_event_innerContext

        def player_event_inner(self):
            return self.getTypedRuleContext(CardParser.Player_event_innerContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_player_event

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlayer_event" ):
                listener.enterPlayer_event(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlayer_event" ):
                listener.exitPlayer_event(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPlayer_event" ):
                return visitor.visitPlayer_event(self)
            else:
                return visitor.visitChildren(self)




    def player_event(self):

        localctx = CardParser.Player_eventContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_player_event)
        try:
            self.state = 173
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [37]:
                self.enterOuterAlt(localctx, 1)
                self.state = 169
                localctx.subject = self.match(CardParser.T__36)
                self.state = 170
                localctx.inner = self.player_event_inner()
                pass
            elif token in [38]:
                self.enterOuterAlt(localctx, 2)
                self.state = 171
                localctx.subject = self.match(CardParser.T__37)
                self.state = 172
                localctx.inner = self.player_event_inner()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Player_event_innerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CardParser.RULE_player_event_inner

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlayer_event_inner" ):
                listener.enterPlayer_event_inner(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlayer_event_inner" ):
                listener.exitPlayer_event_inner(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPlayer_event_inner" ):
                return visitor.visitPlayer_event_inner(self)
            else:
                return visitor.visitChildren(self)




    def player_event_inner(self):

        localctx = CardParser.Player_event_innerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_player_event_inner)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 175
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 17042430230528) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class You_eventContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.subject = None # Token
            self.inner = None # You_event_innerContext

        def you_event_inner(self):
            return self.getTypedRuleContext(CardParser.You_event_innerContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_you_event

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYou_event" ):
                listener.enterYou_event(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYou_event" ):
                listener.exitYou_event(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYou_event" ):
                return visitor.visitYou_event(self)
            else:
                return visitor.visitChildren(self)




    def you_event(self):

        localctx = CardParser.You_eventContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_you_event)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            localctx.subject = self.match(CardParser.T__43)
            self.state = 178
            localctx.inner = self.you_event_inner()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class You_event_innerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CardParser.RULE_you_event_inner

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYou_event_inner" ):
                listener.enterYou_event_inner(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYou_event_inner" ):
                listener.exitYou_event_inner(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYou_event_inner" ):
                return visitor.visitYou_event_inner(self)
            else:
                return visitor.visitChildren(self)




    def you_event_inner(self):

        localctx = CardParser.You_event_innerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_you_event_inner)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 180
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 288195191779622912) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def action_put_counter(self):
            return self.getTypedRuleContext(CardParser.Action_put_counterContext,0)


        def action_create_token(self):
            return self.getTypedRuleContext(CardParser.Action_create_tokenContext,0)


        def action_draw(self):
            return self.getTypedRuleContext(CardParser.Action_drawContext,0)


        def action_buff(self):
            return self.getTypedRuleContext(CardParser.Action_buffContext,0)


        def action_stat_change(self):
            return self.getTypedRuleContext(CardParser.Action_stat_changeContext,0)


        def action_deal_damage(self):
            return self.getTypedRuleContext(CardParser.Action_deal_damageContext,0)


        def action(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CardParser.ActionContext)
            else:
                return self.getTypedRuleContext(CardParser.ActionContext,i)


        def getRuleIndex(self):
            return CardParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction" ):
                return visitor.visitAction(self)
            else:
                return visitor.visitChildren(self)



    def action(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = CardParser.ActionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 24
        self.enterRecursionRule(localctx, 24, self.RULE_action, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 189
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.state = 183
                self.action_put_counter()
                pass

            elif la_ == 2:
                self.state = 184
                self.action_create_token()
                pass

            elif la_ == 3:
                self.state = 185
                self.action_draw()
                pass

            elif la_ == 4:
                self.state = 186
                self.action_buff()
                pass

            elif la_ == 5:
                self.state = 187
                self.action_stat_change()
                pass

            elif la_ == 6:
                self.state = 188
                self.action_deal_damage()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 196
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,14,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = CardParser.ActionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_action)
                    self.state = 191
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 192
                    self.match(CardParser.T__57)
                    self.state = 193
                    self.action(2) 
                self.state = 198
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,14,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Token_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def token_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CardParser.Token_typeContext)
            else:
                return self.getTypedRuleContext(CardParser.Token_typeContext,i)


        def getRuleIndex(self):
            return CardParser.RULE_token_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterToken_type" ):
                listener.enterToken_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitToken_type" ):
                listener.exitToken_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitToken_type" ):
                return visitor.visitToken_type(self)
            else:
                return visitor.visitChildren(self)




    def token_type(self):

        localctx = CardParser.Token_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_token_type)
        try:
            self.state = 210
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [59]:
                self.enterOuterAlt(localctx, 1)
                self.state = 199
                self.match(CardParser.T__58)
                pass
            elif token in [60]:
                self.enterOuterAlt(localctx, 2)
                self.state = 200
                self.match(CardParser.T__59)
                pass
            elif token in [61]:
                self.enterOuterAlt(localctx, 3)
                self.state = 201
                self.match(CardParser.T__60)
                pass
            elif token in [62]:
                self.enterOuterAlt(localctx, 4)
                self.state = 202
                self.match(CardParser.T__61)
                pass
            elif token in [63]:
                self.enterOuterAlt(localctx, 5)
                self.state = 203
                self.match(CardParser.T__62)
                pass
            elif token in [64]:
                self.enterOuterAlt(localctx, 6)
                self.state = 204
                self.match(CardParser.T__63)
                self.state = 205
                self.token_type()
                self.state = 206
                self.match(CardParser.T__64)
                self.state = 207
                self.token_type()
                self.state = 208
                self.match(CardParser.T__65)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class X_statContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.add = None # Signed_intContext

        def affinity(self):
            return self.getTypedRuleContext(CardParser.AffinityContext,0)


        def signed_int(self):
            return self.getTypedRuleContext(CardParser.Signed_intContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_x_stat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterX_stat" ):
                listener.enterX_stat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitX_stat" ):
                listener.exitX_stat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitX_stat" ):
                return visitor.visitX_stat(self)
            else:
                return visitor.visitChildren(self)




    def x_stat(self):

        localctx = CardParser.X_statContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_x_stat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 212
            self.match(CardParser.T__66)
            self.state = 214
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==128:
                self.state = 213
                localctx.add = self.signed_int()


            self.state = 222
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [68]:
                self.state = 216
                self.match(CardParser.T__67)
                pass
            elif token in [69]:
                self.state = 217
                self.match(CardParser.T__68)
                self.state = 218
                self.affinity()
                pass
            elif token in [70]:
                self.state = 219
                self.match(CardParser.T__69)
                pass
            elif token in [71]:
                self.state = 220
                self.match(CardParser.T__70)
                pass
            elif token in [72]:
                self.state = 221
                self.match(CardParser.T__71)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Token_statContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def amount(self):
            return self.getTypedRuleContext(CardParser.AmountContext,0)


        def x_stat(self):
            return self.getTypedRuleContext(CardParser.X_statContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_token_stat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterToken_stat" ):
                listener.enterToken_stat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitToken_stat" ):
                listener.exitToken_stat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitToken_stat" ):
                return visitor.visitToken_stat(self)
            else:
                return visitor.visitChildren(self)




    def token_stat(self):

        localctx = CardParser.Token_statContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_token_stat)
        try:
            self.state = 226
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [126, 127]:
                self.enterOuterAlt(localctx, 1)
                self.state = 224
                self.amount()
                pass
            elif token in [67]:
                self.enterOuterAlt(localctx, 2)
                self.state = 225
                self.x_stat()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TokenContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None # Token_typeContext
            self.stat_ = None # Token_statContext

        def token_type(self):
            return self.getTypedRuleContext(CardParser.Token_typeContext,0)


        def token_stat(self):
            return self.getTypedRuleContext(CardParser.Token_statContext,0)


        def token(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CardParser.TokenContext)
            else:
                return self.getTypedRuleContext(CardParser.TokenContext,i)


        def getRuleIndex(self):
            return CardParser.RULE_token

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterToken" ):
                listener.enterToken(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitToken" ):
                listener.exitToken(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitToken" ):
                return visitor.visitToken(self)
            else:
                return visitor.visitChildren(self)



    def token(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = CardParser.TokenContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 32
        self.enterRecursionRule(localctx, 32, self.RULE_token, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 229
            localctx.type_ = self.token_type()
            self.state = 230
            localctx.stat_ = self.token_stat()
            self._ctx.stop = self._input.LT(-1)
            self.state = 237
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,19,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = CardParser.TokenContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_token)
                    self.state = 232
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 233
                    self.match(CardParser.T__72)
                    self.state = 234
                    self.token(2) 
                self.state = 239
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Action_create_tokenContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def token(self):
            return self.getTypedRuleContext(CardParser.TokenContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_action_create_token

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_create_token" ):
                listener.enterAction_create_token(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_create_token" ):
                listener.exitAction_create_token(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_create_token" ):
                return visitor.visitAction_create_token(self)
            else:
                return visitor.visitChildren(self)




    def action_create_token(self):

        localctx = CardParser.Action_create_tokenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_action_create_token)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 240
            self.match(CardParser.T__73)
            self.state = 241
            self.token(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Action_drawContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CardParser.RULE_action_draw

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_draw" ):
                listener.enterAction_draw(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_draw" ):
                listener.exitAction_draw(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_draw" ):
                return visitor.visitAction_draw(self)
            else:
                return visitor.visitChildren(self)




    def action_draw(self):

        localctx = CardParser.Action_drawContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_action_draw)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 243
            self.match(CardParser.T__74)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Action_buffContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.buff_target = None # Token
            self.derived_quantity = None # Region_derived_quantityContext

        def stat(self):
            return self.getTypedRuleContext(CardParser.StatContext,0)


        def evergreen_keyword(self):
            return self.getTypedRuleContext(CardParser.Evergreen_keywordContext,0)


        def region_derived_quantity(self):
            return self.getTypedRuleContext(CardParser.Region_derived_quantityContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_action_buff

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_buff" ):
                listener.enterAction_buff(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_buff" ):
                listener.exitAction_buff(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_buff" ):
                return visitor.visitAction_buff(self)
            else:
                return visitor.visitChildren(self)




    def action_buff(self):

        localctx = CardParser.Action_buffContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_action_buff)
        self._la = 0 # Token type
        try:
            self.state = 263
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [76]:
                self.enterOuterAlt(localctx, 1)
                self.state = 245
                self.match(CardParser.T__75)
                self.state = 246
                localctx.buff_target = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==32 or _la==33):
                    localctx.buff_target = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 247
                self.match(CardParser.T__76)
                self.state = 248
                self.stat()
                self.state = 250
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 102)) & ~0x3f) == 0 and ((1 << (_la - 102)) & 13) != 0):
                    self.state = 249
                    localctx.derived_quantity = self.region_derived_quantity()


                self.state = 254
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==78:
                    self.state = 252
                    self.match(CardParser.T__77)
                    self.state = 253
                    self.evergreen_keyword()


                self.state = 256
                self.match(CardParser.T__78)
                pass
            elif token in [80]:
                self.enterOuterAlt(localctx, 2)
                self.state = 258
                self.match(CardParser.T__79)
                self.state = 259
                self.stat()
                self.state = 261
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
                if la_ == 1:
                    self.state = 260
                    localctx.derived_quantity = self.region_derived_quantity()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sub_action__damage_each_playerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CardParser.RULE_sub_action__damage_each_player

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSub_action__damage_each_player" ):
                listener.enterSub_action__damage_each_player(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSub_action__damage_each_player" ):
                listener.exitSub_action__damage_each_player(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSub_action__damage_each_player" ):
                return visitor.visitSub_action__damage_each_player(self)
            else:
                return visitor.visitChildren(self)




    def sub_action__damage_each_player(self):

        localctx = CardParser.Sub_action__damage_each_playerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_sub_action__damage_each_player)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 265
            self.match(CardParser.T__80)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Damage_quantityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(CardParser.DIGIT, 0)

        def unit_derived_quantity(self):
            return self.getTypedRuleContext(CardParser.Unit_derived_quantityContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_damage_quantity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDamage_quantity" ):
                listener.enterDamage_quantity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDamage_quantity" ):
                listener.exitDamage_quantity(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDamage_quantity" ):
                return visitor.visitDamage_quantity(self)
            else:
                return visitor.visitChildren(self)




    def damage_quantity(self):

        localctx = CardParser.Damage_quantityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_damage_quantity)
        self._la = 0 # Token type
        try:
            self.state = 271
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [67, 127]:
                self.enterOuterAlt(localctx, 1)
                self.state = 267
                _la = self._input.LA(1)
                if not(_la==67 or _la==127):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 268
                self.match(CardParser.T__81)
                pass
            elif token in [82]:
                self.enterOuterAlt(localctx, 2)
                self.state = 269
                self.match(CardParser.T__81)
                self.state = 270
                self.unit_derived_quantity()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Action_deal_damageContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.target = None # Token

        def sub_action__damage_each_player(self):
            return self.getTypedRuleContext(CardParser.Sub_action__damage_each_playerContext,0)


        def damage_quantity(self):
            return self.getTypedRuleContext(CardParser.Damage_quantityContext,0)


        def damage_quantity_equal_to(self):
            return self.getTypedRuleContext(CardParser.Damage_quantity_equal_toContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_action_deal_damage

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_deal_damage" ):
                listener.enterAction_deal_damage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_deal_damage" ):
                listener.exitAction_deal_damage(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_deal_damage" ):
                return visitor.visitAction_deal_damage(self)
            else:
                return visitor.visitChildren(self)




    def action_deal_damage(self):

        localctx = CardParser.Action_deal_damageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_action_deal_damage)
        self._la = 0 # Token type
        try:
            self.state = 286
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [81]:
                self.enterOuterAlt(localctx, 1)
                self.state = 273
                self.sub_action__damage_each_player()
                pass
            elif token in [83]:
                self.enterOuterAlt(localctx, 2)
                self.state = 274
                self.match(CardParser.T__82)
                self.state = 275
                self.damage_quantity()
                self.state = 276
                self.match(CardParser.T__83)

                self.state = 277
                self.match(CardParser.T__84)
                self.state = 278
                _la = self._input.LA(1)
                if not(((((_la - 32)) & ~0x3f) == 0 and ((1 << (_la - 32)) & 54043195528445953) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 281
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
                if la_ == 1:
                    self.state = 280
                    self.match(CardParser.T__87)


                pass
            elif token in [89]:
                self.enterOuterAlt(localctx, 3)
                self.state = 283
                self.match(CardParser.T__88)
                self.state = 284
                localctx.target = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==90 or _la==91):
                    localctx.target = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 285
                self.damage_quantity_equal_to()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Damage_quantity_equal_toContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def affinity(self):
            return self.getTypedRuleContext(CardParser.AffinityContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_damage_quantity_equal_to

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDamage_quantity_equal_to" ):
                listener.enterDamage_quantity_equal_to(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDamage_quantity_equal_to" ):
                listener.exitDamage_quantity_equal_to(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDamage_quantity_equal_to" ):
                return visitor.visitDamage_quantity_equal_to(self)
            else:
                return visitor.visitChildren(self)




    def damage_quantity_equal_to(self):

        localctx = CardParser.Damage_quantity_equal_toContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_damage_quantity_equal_to)
        try:
            self.state = 292
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [92]:
                self.enterOuterAlt(localctx, 1)
                self.state = 288
                self.match(CardParser.T__91)
                self.state = 289
                self.affinity()
                pass
            elif token in [93]:
                self.enterOuterAlt(localctx, 2)
                self.state = 290
                self.match(CardParser.T__92)
                pass
            elif token in [94]:
                self.enterOuterAlt(localctx, 3)
                self.state = 291
                self.match(CardParser.T__93)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Action_put_counterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def amount_item(self):
            return self.getTypedRuleContext(CardParser.Amount_itemContext,0)


        def counter(self):
            return self.getTypedRuleContext(CardParser.CounterContext,0)


        def counter_target(self):
            return self.getTypedRuleContext(CardParser.Counter_targetContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_action_put_counter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_put_counter" ):
                listener.enterAction_put_counter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_put_counter" ):
                listener.exitAction_put_counter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_put_counter" ):
                return visitor.visitAction_put_counter(self)
            else:
                return visitor.visitChildren(self)




    def action_put_counter(self):

        localctx = CardParser.Action_put_counterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_action_put_counter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 294
            self.match(CardParser.T__94)
            self.state = 295
            self.amount_item()
            self.state = 296
            self.counter()
            self.state = 297
            self.match(CardParser.T__95)
            self.state = 298
            self.counter_target()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Action_stat_changeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lifetime(self):
            return self.getTypedRuleContext(CardParser.LifetimeContext,0)


        def stat(self):
            return self.getTypedRuleContext(CardParser.StatContext,0)


        def evergreen_keyword(self):
            return self.getTypedRuleContext(CardParser.Evergreen_keywordContext,0)


        def region_derived_quantity(self):
            return self.getTypedRuleContext(CardParser.Region_derived_quantityContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_action_stat_change

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_stat_change" ):
                listener.enterAction_stat_change(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_stat_change" ):
                listener.exitAction_stat_change(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_stat_change" ):
                return visitor.visitAction_stat_change(self)
            else:
                return visitor.visitChildren(self)




    def action_stat_change(self):

        localctx = CardParser.Action_stat_changeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_action_stat_change)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 304
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [76]:
                self.state = 300
                self.match(CardParser.T__75)
                self.state = 301
                _la = self._input.LA(1)
                if not(_la==32 or _la==33):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 302
                self.match(CardParser.T__76)
                pass
            elif token in [97]:
                self.state = 303
                self.match(CardParser.T__96)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 312
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                self.state = 306
                self.stat()
                self.state = 307
                self.match(CardParser.T__77)
                self.state = 308
                self.evergreen_keyword()
                pass

            elif la_ == 2:
                self.state = 310
                self.stat()
                pass

            elif la_ == 3:
                self.state = 311
                self.evergreen_keyword()
                pass


            self.state = 315
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 102)) & ~0x3f) == 0 and ((1 << (_la - 102)) & 13) != 0):
                self.state = 314
                self.region_derived_quantity()


            self.state = 317
            self.lifetime()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Counter_targetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.self_target = None # Token
            self.target = None # Token
            self.target_each = None # Token

        def region_derived_quantity(self):
            return self.getTypedRuleContext(CardParser.Region_derived_quantityContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_counter_target

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCounter_target" ):
                listener.enterCounter_target(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCounter_target" ):
                listener.exitCounter_target(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCounter_target" ):
                return visitor.visitCounter_target(self)
            else:
                return visitor.visitChildren(self)




    def counter_target(self):

        localctx = CardParser.Counter_targetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_counter_target)
        self._la = 0 # Token type
        try:
            self.state = 327
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [98]:
                self.enterOuterAlt(localctx, 1)
                self.state = 319
                localctx.self_target = self.match(CardParser.T__97)
                pass
            elif token in [76]:
                self.enterOuterAlt(localctx, 2)
                self.state = 320
                self.match(CardParser.T__75)
                self.state = 321
                localctx.target = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==32 or _la==33):
                    localctx.target = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 323
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
                if la_ == 1:
                    self.state = 322
                    self.region_derived_quantity()


                pass
            elif token in [85]:
                self.enterOuterAlt(localctx, 3)
                self.state = 325
                self.match(CardParser.T__84)
                self.state = 326
                localctx.target_each = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==32 or ((((_la - 99)) & ~0x3f) == 0 and ((1 << (_la - 99)) & 7) != 0)):
                    localctx.target_each = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Region_derived_quantityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def affinity(self):
            return self.getTypedRuleContext(CardParser.AffinityContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_region_derived_quantity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegion_derived_quantity" ):
                listener.enterRegion_derived_quantity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegion_derived_quantity" ):
                listener.exitRegion_derived_quantity(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegion_derived_quantity" ):
                return visitor.visitRegion_derived_quantity(self)
            else:
                return visitor.visitChildren(self)




    def region_derived_quantity(self):

        localctx = CardParser.Region_derived_quantityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_region_derived_quantity)
        try:
            self.state = 336
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [102]:
                self.enterOuterAlt(localctx, 1)
                self.state = 329
                self.match(CardParser.T__101)
                self.state = 332
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [103]:
                    self.state = 330
                    self.match(CardParser.T__102)
                    pass
                elif token in [118]:
                    self.state = 331
                    self.affinity()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [104]:
                self.enterOuterAlt(localctx, 2)
                self.state = 334
                self.match(CardParser.T__103)
                pass
            elif token in [105]:
                self.enterOuterAlt(localctx, 3)
                self.state = 335
                self.match(CardParser.T__104)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LifetimeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CardParser.RULE_lifetime

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLifetime" ):
                listener.enterLifetime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLifetime" ):
                listener.exitLifetime(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLifetime" ):
                return visitor.visitLifetime(self)
            else:
                return visitor.visitChildren(self)




    def lifetime(self):

        localctx = CardParser.LifetimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_lifetime)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 338
            self.match(CardParser.T__78)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CounterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stat(self):
            return self.getTypedRuleContext(CardParser.StatContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_counter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCounter" ):
                listener.enterCounter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCounter" ):
                listener.exitCounter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCounter" ):
                return visitor.visitCounter(self)
            else:
                return visitor.visitChildren(self)




    def counter(self):

        localctx = CardParser.CounterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_counter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 340
            self.stat()
            self.state = 341
            self.match(CardParser.T__105)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.power = None # Signed_intContext
            self.defense = None # Signed_intContext

        def signed_int(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CardParser.Signed_intContext)
            else:
                return self.getTypedRuleContext(CardParser.Signed_intContext,i)


        def getRuleIndex(self):
            return CardParser.RULE_stat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat" ):
                listener.enterStat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat" ):
                listener.exitStat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStat" ):
                return visitor.visitStat(self)
            else:
                return visitor.visitChildren(self)




    def stat(self):

        localctx = CardParser.StatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_stat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 343
            localctx.power = self.signed_int()
            self.state = 344
            self.match(CardParser.T__106)
            self.state = 345
            localctx.defense = self.signed_int()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Evergreen_keywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CardParser.RULE_evergreen_keyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEvergreen_keyword" ):
                listener.enterEvergreen_keyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEvergreen_keyword" ):
                listener.exitEvergreen_keyword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEvergreen_keyword" ):
                return visitor.visitEvergreen_keyword(self)
            else:
                return visitor.visitChildren(self)




    def evergreen_keyword(self):

        localctx = CardParser.Evergreen_keywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_evergreen_keyword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 347
            _la = self._input.LA(1)
            if not(_la==108 or _la==109):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def amount(self):
            return self.getTypedRuleContext(CardParser.AmountContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_keyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyword" ):
                listener.enterKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyword" ):
                listener.exitKeyword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeyword" ):
                return visitor.visitKeyword(self)
            else:
                return visitor.visitChildren(self)




    def keyword(self):

        localctx = CardParser.KeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_keyword)
        try:
            self.state = 356
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [110]:
                self.enterOuterAlt(localctx, 1)
                self.state = 349
                self.match(CardParser.T__109)
                pass
            elif token in [111]:
                self.enterOuterAlt(localctx, 2)
                self.state = 350
                self.match(CardParser.T__110)
                pass
            elif token in [112]:
                self.enterOuterAlt(localctx, 3)
                self.state = 351
                self.match(CardParser.T__111)
                pass
            elif token in [113]:
                self.enterOuterAlt(localctx, 4)
                self.state = 352
                self.match(CardParser.T__112)
                self.state = 353
                self.amount()
                pass
            elif token in [114]:
                self.enterOuterAlt(localctx, 5)
                self.state = 354
                self.match(CardParser.T__113)
                self.state = 355
                self.amount()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def graft(self):
            return self.getTypedRuleContext(CardParser.GraftContext,0)


        def augment(self):
            return self.getTypedRuleContext(CardParser.AugmentContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_mod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMod" ):
                listener.enterMod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMod" ):
                listener.exitMod(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMod" ):
                return visitor.visitMod(self)
            else:
                return visitor.visitChildren(self)




    def mod(self):

        localctx = CardParser.ModContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_mod)
        try:
            self.state = 360
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [115]:
                self.enterOuterAlt(localctx, 1)
                self.state = 358
                self.graft()
                pass
            elif token in [116]:
                self.enterOuterAlt(localctx, 2)
                self.state = 359
                self.augment()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GraftContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.limit = None # AmountContext

        def amount(self):
            return self.getTypedRuleContext(CardParser.AmountContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_graft

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGraft" ):
                listener.enterGraft(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGraft" ):
                listener.exitGraft(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGraft" ):
                return visitor.visitGraft(self)
            else:
                return visitor.visitChildren(self)




    def graft(self):

        localctx = CardParser.GraftContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_graft)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 362
            self.match(CardParser.T__114)
            self.state = 364
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==126 or _la==127:
                self.state = 363
                localctx.limit = self.amount()


            self.state = 366
            self.match(CardParser.T__65)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AugmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.limit = None # Token


        def getRuleIndex(self):
            return CardParser.RULE_augment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAugment" ):
                listener.enterAugment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAugment" ):
                listener.exitAugment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAugment" ):
                return visitor.visitAugment(self)
            else:
                return visitor.visitChildren(self)




    def augment(self):

        localctx = CardParser.AugmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_augment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 368
            self.match(CardParser.T__115)
            self.state = 370
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==117:
                self.state = 369
                localctx.limit = self.match(CardParser.T__116)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AffinityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CardParser.RULE_affinity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAffinity" ):
                listener.enterAffinity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAffinity" ):
                listener.exitAffinity(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAffinity" ):
                return visitor.visitAffinity(self)
            else:
                return visitor.visitChildren(self)




    def affinity(self):

        localctx = CardParser.AffinityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_affinity)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 372
            self.match(CardParser.T__117)
            self.state = 373
            _la = self._input.LA(1)
            if not(((((_la - 119)) & ~0x3f) == 0 and ((1 << (_la - 119)) & 31) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 374
            self.match(CardParser.T__65)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signed_intContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SIGN(self):
            return self.getToken(CardParser.SIGN, 0)

        def DIGIT(self):
            return self.getToken(CardParser.DIGIT, 0)

        def getRuleIndex(self):
            return CardParser.RULE_signed_int

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSigned_int" ):
                listener.enterSigned_int(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSigned_int" ):
                listener.exitSigned_int(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSigned_int" ):
                return visitor.visitSigned_int(self)
            else:
                return visitor.visitChildren(self)




    def signed_int(self):

        localctx = CardParser.Signed_intContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_signed_int)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 376
            self.match(CardParser.SIGN)
            self.state = 377
            self.match(CardParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AmountContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(CardParser.DIGIT, 0)

        def NUMBER_WORD(self):
            return self.getToken(CardParser.NUMBER_WORD, 0)

        def getRuleIndex(self):
            return CardParser.RULE_amount

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAmount" ):
                listener.enterAmount(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAmount" ):
                listener.exitAmount(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAmount" ):
                return visitor.visitAmount(self)
            else:
                return visitor.visitChildren(self)




    def amount(self):

        localctx = CardParser.AmountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_amount)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 379
            _la = self._input.LA(1)
            if not(_la==126 or _la==127):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Amount_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def amount(self):
            return self.getTypedRuleContext(CardParser.AmountContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_amount_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAmount_item" ):
                listener.enterAmount_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAmount_item" ):
                listener.exitAmount_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAmount_item" ):
                return visitor.visitAmount_item(self)
            else:
                return visitor.visitChildren(self)




    def amount_item(self):

        localctx = CardParser.Amount_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_amount_item)
        try:
            self.state = 383
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [23]:
                self.enterOuterAlt(localctx, 1)
                self.state = 381
                self.match(CardParser.T__22)
                pass
            elif token in [126, 127]:
                self.enterOuterAlt(localctx, 2)
                self.state = 382
                self.amount()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unit_derived_quantityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def affinity(self):
            return self.getTypedRuleContext(CardParser.AffinityContext,0)


        def getRuleIndex(self):
            return CardParser.RULE_unit_derived_quantity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit_derived_quantity" ):
                listener.enterUnit_derived_quantity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit_derived_quantity" ):
                listener.exitUnit_derived_quantity(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnit_derived_quantity" ):
                return visitor.visitUnit_derived_quantity(self)
            else:
                return visitor.visitChildren(self)




    def unit_derived_quantity(self):

        localctx = CardParser.Unit_derived_quantityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_unit_derived_quantity)
        try:
            self.state = 389
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [124]:
                self.enterOuterAlt(localctx, 1)
                self.state = 385
                self.match(CardParser.T__123)

                self.state = 386
                self.match(CardParser.T__124)
                pass
            elif token in [92]:
                self.enterOuterAlt(localctx, 2)
                self.state = 387
                self.match(CardParser.T__91)
                self.state = 388
                self.affinity()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[12] = self.action_sempred
        self._predicates[16] = self.token_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def action_sempred(self, localctx:ActionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 1)
         

    def token_sempred(self, localctx:TokenContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 1)
         




